{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifts.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setinputVal","onSubmit","e","preventDefault","trim","length","cat","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","setTimeout","useFetchGifs","key","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"qMAIaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EAEZC,mBAAS,IAFG,mBAEvCC,EAFuC,KAE3BC,EAF2B,KAqB9C,OAII,0BAAMC,SAdW,SAACC,GAElBA,EAAEC,iBAEEJ,EAAWK,OAAOC,OAAS,GAC3BR,GAAc,SAAAS,GAAG,OAAKP,GAAL,mBAAmBO,SAUpC,2BACIC,KAAK,OACLC,MAAOT,EACPU,SAvBc,SAACP,GAEvBF,EAAYE,EAAEQ,OAAOF,Y,uBCZhBG,EAAO,uCAAG,WAAMC,GAAN,uBAAAC,EAAA,6DACbC,EADa,iDACkCC,UAAUH,GAD5C,+DAEAI,MAAMF,GAFN,cAEbG,EAFa,gBAIEA,EAAKC,OAJP,uBAIZC,EAJY,EAIZA,KACDC,EAAOD,EAAKE,KAAM,SAAAC,GAAQ,IAAD,EAC3B,MAAM,CACFC,GAAID,EAAIC,GACRC,MAAMF,EAAIE,MACVV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QATvB,kBAgBZM,GAhBY,4CAAH,sDCEPO,EAAc,SAAC,GAAmB,EAAlBJ,GAAmB,IAAhBC,EAAe,EAAfA,MAAMV,EAAS,EAATA,IAIlC,OACI,yBAAKc,UAAY,0CACb,yBAAKC,IAAOf,EAAKgB,IAAON,IACxB,2BAAIA,KCHHO,EAAU,SAAC,GAAgB,IAAfnB,EAAc,EAAdA,SAAc,ECAX,SAACA,GAAa,IAAD,EAEXd,mBAAS,CAC/BqB,KAAM,GACNa,SAAS,IAJwB,mBAE9BC,EAF8B,KAEvBC,EAFuB,KA6BrC,OApBAC,qBAAU,WACNxB,EAAQC,GACHwB,MAAK,SAAAC,GACFC,YAAW,WACPJ,EAAS,CACLf,KAAMkB,EACNL,SAAS,MAEd,UAGZ,CAACpB,IASGqB,ED1BuBM,CAAa3B,GAA/Ba,EAHuB,EAG5BN,KAAYa,EAHgB,EAGhBA,QAiBnB,OACI,oCACA,wBAAIJ,UAAY,yCAAyChB,GAGxDoB,GAAW,uBAAGJ,UAAY,oCAAf,WAJZ,IAKA,yBAAKA,UAAU,aAcHH,EAAOJ,KAAK,SAAAC,GAAG,OAAK,kBAAC,EAAD,eAChBkB,IAAOlB,EAAIC,IACPD,UE5CfmB,EAAe,WAAM,MAIM3C,mBAAS,CAAC,cAJhB,mBAIvB4C,EAJuB,KAIX7C,EAJW,KAW9B,OACI,6BACI,wBAAI+B,UAAY,qCAAhB,YACA,kBAAC,EAAD,CAAa/B,cAAeA,IAC5B,6BAIA,4BAEQ6C,EAAWrB,KAAK,SAAAT,GAAQ,OAExB,kBAAC,EAAD,CACIA,SAAYA,EACZ4B,IAAO5B,U,MCxB/B+B,IAASC,OACL,kBAAC,EAAD,MACFC,SAASC,eAAe,U","file":"static/js/main.f9067232.chunk.js","sourcesContent":["import React, { useState } from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nexport const AddCategory = ({ setCategories }) => {\r\n\r\n    const [inputValue, setinputVal] = useState('')//Evitar errores hay que poner un string vacio '' si no queremos un string por defecto ya que sino sera undefined\r\n\r\n    //Creamos una constante porque sera mas facil de ver de donde extraemos el valor del event\r\n\r\n    const handleInputChange = (e) => {\r\n        //Asi cambiamos el valor dentro de inputValue de 'Hola mundo'\r\n        setinputVal(e.target.value);\r\n    }\r\n\r\n    const handleSubmit = (e) => {\r\n        // Evita que el form recargue todos los elementos de la pagina\r\n        e.preventDefault();\r\n        // console.log('Hecho!')//Comprobacion de que funciona el enter\r\n        if (inputValue.trim().length > 2) {\r\n            setCategories(cat => [inputValue,...cat]);\r\n        }\r\n\r\n    }\r\n\r\n    return (\r\n        // An HTML form is used to collect user input.\r\n        // Quitamos el fragment <></> dado que solo estamos regresando UNA sola etiqueta\r\n        // Tambien al usar el form nos recarga todos los elementos de la pagina lo cual es muy anticuado ya.\r\n        <form onSubmit={handleSubmit}>\r\n            <input\r\n                type=\"text\"//Buena practica espeficicar lo que va a contener el input\r\n                value={inputValue}\r\n                onChange={handleInputChange}\r\n            />\r\n        </form>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}\r\n","export const getGifs = async(category) => {\r\n    const url =`https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=20&api_key=lu5l27yS2utR27Smt5UPNPrwjX7m1Ppx`\r\n    const resp = await fetch(url);//Fetch es la respuesta de una funcion async con la info del api\r\n    //usamos desestructuracion de la data para solo obtener los arreglos con las imagenes\r\n    const {data} = await resp.json();//Transforma la info del fetch a text o json format\r\n    const gifs = data.map ( img => {\r\n        return{\r\n            id: img.id,\r\n            title:img.title,\r\n            url: img.images?.downsized_medium.url,//El signo de ? es para validar que el arreglo tenga la propiedad de images\r\n        }\r\n    })\r\n\r\n\r\n    // console.log(gifs);\r\n\r\n    return gifs;\r\n}\r\n","import React from 'react'\r\n\r\nexport const GifGridItem = ({id,title,url}) => {\r\n\r\n    // console.log(id, title,url);\r\n\r\n    return (\r\n        <div className = \"card animate__animated animate__fadeIn\">\r\n            <img src = {url} alt = {title}/>\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react'//RAFC para crear un componente facil\r\nimport { useFetchGifs } from '../hooks/useFetchGifts'\r\nimport { GifGridItem } from './GifGridItem';\r\n//El useEfect nos permitira ejecutar ciertas parte del codigo de manera condicional\r\n\r\n\r\nexport const GifGrid = ({category}) => {\r\n\r\n\r\n    const {data:images,loading} = useFetchGifs(category);//renombramos el data ya que realmente carga images no datos\r\n\r\n    // console.log(loading);\r\n\r\n\r\n\r\n    // const [images, setImages] = useState([])\r\n\r\n    // // const [count, setCount] = useState(0); Lo usamos para hacer pruebas de las peticiones http\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // getGifs();\r\n\r\n    return (\r\n        <>\r\n        <h3 className = \"animate__animated animate__fadeInDown\">{category}</h3>\r\n\r\n        {/* {loading ? 'Cargando...' : 'Data Cargada'} */}\r\n        {loading && <p className = \"animate__animated animate__flash\">Loading</p>  } {/*No evaluaremos el caso de False*/}\r\n        <div className=\"card-grid\">\r\n            {/* Lo usamos para hacer pruebas HTTP */}\r\n            {/* <h3>{count}</h3>{/*Al hacer esta validacion vemos que React esta volviendo hacer la peticion http a la api porque detecto un cambio y hay que actualizar las referemcias */}\r\n            {/* <button onClick = {() => setCount (count + 1)}></button> */}\r\n            {/* CREAREMOS UN NUEVO COMPONENTE PARA ... */}\r\n            {/* { <ol> \r\n                {\r\n                    images.map( ({id,title}) => \r\n                        (<li key = {id}>{title}</li>)//Las llaves en el li es para indicar un return explicito()\r\n                    )\r\n                }\r\n            </ol>  */}\r\n\r\n                {\r\n                    images.map( img =>( <GifGridItem \r\n                        key = {img.id}\r\n                        {...img}//usaremos el spread para poder hacer desestructuracion en GifGridItem de cada una de las propiedades ya que hemos pasado cada una como propiedad individual\r\n                        />\r\n                    ))\r\n                }\r\n        </div> \r\n        </>\r\n    )\r\n}\r\n","//use indica que es un hook\r\n\r\nimport { useEffect, useState } from \"react\"\r\nimport {getGifs} from '../helpers/getGifs'\r\n\r\n//no hay que importar react ya que no vamos a regresar JSX\r\nexport const useFetchGifs = (category) =>{\r\n\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    \r\n\r\n    useEffect(() => {\r\n        getGifs(category)\r\n            .then(imgs => {\r\n                setTimeout(() => {\r\n                    setState({\r\n                        data: imgs,\r\n                        loading: false\r\n                    });\r\n                }, 1000);\r\n\r\n            })// tambien puede ser .then(setImages) dado que el argumento es mandado como el primer elemento\r\n    }, [category])//Solo sera renderizado por primera e unica vez\r\n\r\n\r\n    // setTimeout( () => {\r\n    //         data: [1,2,3,4,5,6,7],\r\n    //         loading: false\r\n    //     })\r\n    // },3000);\r\n\r\n    return state; //{data[], loading:true}\r\n\r\n}","import React, { useState } from 'react'\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    // const categories = ['One Punch', 'Samurai X', 'Dragon Ball']//Solo se usa una const como arreglo solo si el arreglo JAMAS va a cambiar en caso contrario usaremos un hook(useState)\r\n\r\n    const [categories, setCategories] = useState(['Peppa Pig'])\r\n\r\n    // REFERENCIA DE COMO LO HACIAMOS, AHORA VAMOS A HACERLO CON UN COMPONENTE\r\n    // const handleAdd = () => {\r\n    //     setCategories(() => [...categories,'Bob Toronja'])\r\n    // }\r\n\r\n    return (\r\n        <div>\r\n            <h2 className = \"animate__animated animate__fadeIn\">Nanowebs</h2>\r\n            <AddCategory setCategories={setCategories}/>\r\n            <hr />\r\n            {/* REFERENCIA */}\r\n            {/* <button onClick={handleAdd}>Agregar</button> */}\r\n\r\n            <ol>\r\n                {\r\n                    categories.map( category => (//todo map tiene un indice implicito el cual lo podemos usar como KEY unica de cada elemento mapeado\r\n            // /*RETURN EXPLICITO*/<li key={category}>{category}</li>//Necesitamos asigarle un Key Unico a cada elemento\r\n                    <GifGrid \r\n                        category = {category}\r\n                        key = {category}\r\n                        />\r\n                        \r\n            ))\r\n                }\r\n\r\n            </ol>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\nimport './index.css';\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}